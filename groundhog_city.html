<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Groundhog City Simulation</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.10/esri/css/main.css">
  <link rel="stylesheet" href="styles/groundhog_city.css">
  <script src="https://js.arcgis.com/4.10/"></script>

  <script>

    //State variables
    var isStopped = true;
    var isReset = true;
    var isPaused = false;
    var isRunning = false;
    var isRunningOneStep = false;

    const maxInfectionDuration = 6;
    const maxInfectionDistance = 200; // (m)

    //Globals
    var numSeeds = 0;
    var totalBuildings = -1;
    var infectionDay = 0;
    var svDefaultColor = [0,0,255,1];
    var infectionDistance = 25;
    var mortalityRate = 0; // 0..1
    var infectionDuration = 3;
    var infectionRate = 1; // 0..1

    // select infected houses
    // set ageing duration
    // set % terminal or reinfectable
    // set buffer distance
    // run simulation till pause or to 100 (keep score)
    //  Infect adjacent houses
    //  Age infection at each infected house
    //  Update renderer
    // TODO: Show score (Number of houses infected?)
    // DONE: Create on screen controls - reset, duration, terminal, distance
    // TODO: Show infection %, mortality %
    // TODO: Help dialog
    // TODO: Intro dialog/title dialog
    // DONE: Add ability to step forward one day >|

    // Credits
    // https://www.freeiconspng.com (skull icon)

    function objToString(obj){
      //console.log("in objToString()");
      var res = '';
      if (obj == null){
        res = 'null';
      } else {
        for (objItem in obj){
          res += objItem + ' ' + obj[objItem] + ' ' + typeof(objItem) + '\r\n';
        }
      }
      return res;
    }

    function createInfectedRenderers(iList, iColor){
    	var res = [];
      for (item in iList){
      	res[res.length] = JSON.parse('{"value": "' + iList[item] +
        '","label": "test","symbol": {"type": "mesh-3d","symbolLayers": [{"type": "fill","material": {"color": "' + iColor + '","colorMixMode": "replace"}}]}}');
      }
      return res;
    }

    function setSlider(sName, vName, min, max, current, execCode){
      var slider = document.getElementById(sName);
      var output = document.getElementById(vName);
      slider.min = min;
      slider.max = max;
      slider.value = current;
      output.innerHTML = slider.value;

      slider.oninput = function() {
        output.innerHTML = this.value;
        if (execCode){
          execCode();
        }
      }
    }

    require([
      "esri/Map",
      "esri/views/SceneView",
      "esri/layers/SceneLayer",
      "esri/layers/GraphicsLayer",
      "esri/Graphic",
      "esri/geometry/geometryEngine",
      "esri/renderers/smartMapping/statistics/summaryStatistics",
      "esri/tasks/support/Query"
    ], function(Map,
      SceneView,
      SceneLayer,
      GraphicsLayer,
      Graphic,
      geometryEngine,
      summaryStatistics,
      Query) {

      var infected = []; //will be an array of arrays
      var infectedGeometry = {}; //going to try saving geometry to not query too much
      var deceased = [];// will be an array of ids

      // Create Map
      var map = new Map({
        basemap: "dark-gray",
        ground: "world-elevation"
      });

      // Create the SceneView
      var view = new SceneView({
        container: "viewDiv",
        map: map,
        camera: {
          position: [(-122.47876 + ((Math.random()-0.5)/1000)), (48.75368 + ((Math.random()-0.5)/1000)), 1000],
          tilt: 20,
          heading: 50
        },
        environment: {
          background: {
            type: "color",
            color: [30, 30, 30, 1]
          },
          starsEnabled: false,
          atmosphereEnabled: false
        }
      });

      // Create a GraphicsLayer to add buffer graphics
      var bufferLayer = new GraphicsLayer();
      map.add(bufferLayer);

      // Create SceneLayer and add to the map
      var sceneLayer = new SceneLayer({
        portalItem: {
          id: "fa0e0058ff394dd7a9902ede1d04721b"
        },
        popupEnabled: false
      });
      map.add(sceneLayer);

      sceneLayer.when(function(){
        //view.goTo(sceneLayer.fullExtent);
        //let cam = view.camera.clone();
        //cam.position.z = 150;
        //view.camera = cam;
        //view.camera.position.z = 250;

        summaryStatistics({
          layer: sceneLayer,
          field: "YEAR"
        }).then(function(stats){
          console.log('Total buildings = ' + stats.count);
          totalBuildings = stats.count;
        });
      });

      // Create MeshSymbol3D for symbolizing SceneLayer
      var symbol = {
        type: "mesh-3d", // autocasts as new MeshSymbol3D()
        symbolLayers: [{
          type: "fill", // autocasts as new FillSymbol3DLayer()
          // If the value of material is not assigned, the default color will be red
          material: {
            color: [255, 0, 0]
          }
        }]
      };

      var infectedList = [1808,1752,1712];

      function getUniqueValueRenderer() {
        var res = {
          type: "unique-value",
          field: "OBJECTID",
          defaultSymbol: {
            type: "mesh-3d",
            symbolLayers: [{
              type: "fill",
              material: {
                color: svDefaultColor,
                colorMixMode: "replace"
              }
            }]
          },
          uniqueValueInfos: [],
          legendOptions: { title: "Infected" }
        };
        res.uniqueValueInfos = createInfectedRenderers(infected[0], "red");
        if ((infected[1] != null) && (infected[1].length > 0)){
          res.uniqueValueInfos.concat(createInfectedRenderers(infected[1], "brown"));
        }
        if (deceased.length > 0){
          res.uniqueValueInfos.concat(createInfectedRenderers(deceased, "black"));
        }
        return res;
      }

      sceneLayer.renderer = getUniqueValueRenderer();

      //for testing
      var polySym = {
        type: "simple-fill", // autocasts as new SimpleFillSymbol()
        color: [200, 0, 0, 0.2],
        outline: {
          color: [220, 0, 0, 0.5],
          width: 1
        }
      };

      function getNeighbors(oid){
        //Query the scene layer by id to get the graphic

        var query = sceneLayer.createQuery();
        query.where = "OBJECTID = " + oid;
        query.returnGeometry = true;
        query.outFields = ['YEAR', 'TYPE'];
        var resultGeom = null;
        sceneLayer.queryFeatures(query)
          .then(function(result){
            resultGeom = result.features[0].geometry;
            //console.log("resultGeom = " + resultGeom.type);

            //Query the scene layer by a distance from the graphic geometry
            var query2 = sceneLayer.createQuery();
            query2.geometry = geometryEngine.geodesicBuffer(resultGeom,
              parseInt(infectionDistance)/1000, "kilometers");
            bufferLayer.add(new Graphic({
              geometry: query2.geometry,
              symbol: polySym
            }));
            query2.spatialRelationship = "intersects";
            query2.outFields = ['OBJECTID', 'YEAR', 'TYPE'];
            sceneLayer.queryFeatures(query2)
              .then(function(result2){
                for (item in result2.features){
                  t = result2.features[item].attributes.OBJECTID;

                  //TODO: Add results to the newly infected list

                }
              });
          });

        //return an array of the neighbor OBJECTIDs minus the id of the input graphic
      }

      // capture click events on the view
      view.on("click", function(event) {
        // get the returned screen x, y coordinates and use it
        // with hitTest to find if any graphics were clicked
        // (using promise chaining for cleaner code and error handling)
        view.hitTest(event).then(function(response) {
          var result = response.results[0];
          if (result && result.graphic) {
            return result.graphic;
          }
        }).then(function(graphic) {
          if (graphic){// for some reason this is coming across as undefined
            // now extract the object id from the graphic
            if (isStopped && isReset){
              var tid = graphic.attributes.OBJECTID;
              var tind = infected[0].findIndex(function(tval){return (tval == tid);});
              //console.log("tid=" + tid + "  tind=" + tind);
              if (tind > -1){
                infected[0].splice(tind, 1);
              } else {
                infected[0][infected[0].length] = tid;
              }
              //console.log(JSON.stringify(graphic));
              //console.log(infectedList);
              sceneLayer.renderer = getUniqueValueRenderer();
              //getNeighbors(tid); This was a test method.  Don't need to do this any longer.
            }
          } else {
            console.log("got undefined graphic");
          }
        }).catch(function(error) {
          console.error(error);
        });
      });

      view.ui.add("paneDiv", "bottom-left");
      view.ui.add("runDiv", "bottom-right");
      view.ui.add("scoreDiv", "top-right");

      function resetInfected(){
        //Set up the infected array
        infected = [];
        for (iD = 0; iD < infectionDuration; iD++){
         infected.push([]);
        }
        console.log('Initialized infected[]');
      }
      window.resetInfected = resetInfected;

      function initializeSim(infectionDuration){

        //init infected array
        resetInfected();
        sceneLayer.renderer = getUniqueValueRenderer();

        //Clear numSeeds
        numSeeds = 0;
        //Clear infection day
        infectionDay = 0;

        isStopped = true;
        isReset = true;
        isPaused = false;
        isRunning = false;

        // Clear any graphics layers
        bufferLayer.removeAll();
        setProgress("currentInfectionDiv", 0, false, "currentInfectedVal", (0 + "%"));
        document.getElementById("currentDayVal").innerHTML = "0";
      }
      window.initializeSim = initializeSim;

      //Change the position of a vertical progress indicator
      function setProgress(divName, val, down, textSpan, textVal) {
      	if (!down){
        	val = 100 - val;
        }
        var elem = document.getElementById(divName);
        elem.style.height = val + '%';
        if (textVal){
          document.getElementById(textSpan).innerHTML = textVal;
        }
      }
      window.setProgress = setProgress;

      //Run the Simulation
      async function runSim(){
        if (isRunning || isRunningOneStep){
          if (infectionDay == 0){
            var simParams = "\r\nSim Params\r\n";
            simParams += "mortalityRate: " + mortalityRate + "\r\n";
            simParams += "infectionDistance: " + infectionDistance + "\r\n";
            simParams += "infectionDuration: " + infectionDuration + "\r\n";
            simParams += "infectionRate: " + infectionRate + "\r\n";
            simParams += "initial infection count: " + infected[0].length + "\r\n";
            for (ii in infected[0]){
              simParams += "   ID: " + infected[0][ii] + "\r\n";
            }
            console.log(simParams);

            // TODO: Zoom to the extent of the infected seeds on Day 0
          }

          // DONE: Create simulation logic
          var query = null;
          var bigBuffer = null; // Geometry to use to union the buffers
          var tempBuffer = null;
          var newlyInfected = [];
          //var sceneLayerView = null;

          // get the current SceneLayerView to try to speed things up
          //let wlv = view.whenLayerView(sceneLayer);
          //try{
          //  sceneLayerView = await wlv;
          //} catch (err) {
          //  console.log("Error getting sceneLayerView: " + err);
          //}

          // Loop through the current infected list
          // TODO: Convert this to an IN where clause and only do the buffer operation after the query has returned
          // console.log("About to query buffer geometries");
          for (age in infected){
            //console.log(infected[age]);
            for (iid in infected[age]){
              let oid = infected[age][iid];

              if (infectedGeometry[oid] == null){
                query = sceneLayer.createQuery();
                //query = new Query(); // tried to convert to a SLV but I don't think you can retrieve the geometry
                query.objectIds = [oid];
                query.returnGeometry = true;
                query.outFields = ['*'];
                // Query the feature to get the grapic
                // Note converted from .then to async/await becuase of the better flow control
                //let myquery = sceneLayerView.queryFeatures(query);
                let myquery = sceneLayer.queryFeatures(query);
                let result = await myquery;
                infectedGeometry[oid] = result.features[0].geometry;
              }

              if (infectedGeometry[oid] != null){
                // Create the buffer based on the graphic and infectionDistance
                tempBuffer = geometryEngine.geodesicBuffer(infectedGeometry[oid],
                  infectionDistance/1000, "kilometers");

                // Union the buffer to the combined buffer geometry
                if (bigBuffer == null){
                  bigBuffer = tempBuffer;
                } else {
                  bigBuffer = geometryEngine.union([tempBuffer, bigBuffer]);
                }
              } else { //TODO: get rid of this if/then if it's unnecessary
                console.log("Geometry null for " + oid);
              }
            }
          }

          //console.log("About to find buildings within buffer");
          if (bigBuffer != null){
            // Draw the unioned buffer
            bufferLayer.add(new Graphic({
              geometry: bigBuffer,
              symbol: polySym
            }));
            tempBuffer = geometryEngine.geodesicBuffer(bigBuffer.extent,
              0.250, "kilometers");
            view.goTo(tempBuffer.extent);

            // Intersect the unioned geometry with the layer to get the feature set
            var query2 = sceneLayer.createQuery();
            //var query2 = new Query();
            query2.geometry = bigBuffer;
            query2.spatialRelationship = "intersects";
            query2.outFields = ['OBJECTID'];
            let myquery = sceneLayer.queryFeatures(query2);
            let result = await myquery;

            for (item in result.features){
              let t = result.features[item].attributes.OBJECTID;
              if (deceased.indexOf(t) == -1){
                // Add results to the newly infected list
                // TODO: change this to factor in infectionRate
                if (Math.random() < infectionRate){
                  newlyInfected.push(t);
                }
              } // else can't reinfect
            }

            if (newlyInfected.length > 1){
              // Sort newlyInfected
              newlyInfected.sort(function(a, b){return a-b}); // assuming IDs are numbers

              // Deduplicate newlyInfected
              var tt = 1;
              while (tt < newlyInfected.length){
                if(newlyInfected[tt] == newlyInfected[tt-1]){
                  newlyInfected.splice(tt, 1);
                } else {
                  tt++;
                }
              }
            }
          } // end if bigBuffer != null
          //console.log("bigBuffer is null: " + (bigBuffer == null));

          // Calculate if the current oldest infected should be cleared or killed; if killed, add them to the deceased list
          for (old in infected[infected.length-1]){
            if (Math.random() < mortalityRate){
              deceased.push(infected[infected.length-1][old]);

              // TODO: Remove from infectedGeometry
            }
          }
          deceased.sort();
          //console.log("Deceased count: " + deceased.length);

          // Age the arrays of the infected list
          for (ai = infected.length - 1; ai > 0; ai--){
            infected[ai] = [].concat(infected[ai - 1]);
          }

          // Add the new items from the temp array to the 0 position of infected list
          infected[0] = [].concat(newlyInfected);

          // TODO: redraw the renderers
          sceneLayer.renderer = getUniqueValueRenderer();

          //update the progress indicator
          var count = 0;
          for (age in infected){
            count += infected[age].length;
          }
          count += deceased.length;
          var pctCount = Math.round((count + deceased.length)/totalBuildings*100, 2);
          setProgress("currentInfectionDiv", pctCount, false, "currentInfectedVal", (pctCount + "%"));
          console.log("Day: " + infectionDay + " Infected: " + count + " Deceased: " + deceased.length);

          infectionDay++;
          document.getElementById("currentDayVal").innerHTML = infectionDay;
        } else if (isPaused) {
        }
        if (!isRunningOneStep){
          setTimeout("runSim();", 500);
        }
      } // end runSim
      window.runSim = runSim;

      //reset the map extent to a helpful extent
      function resetMap(){
        //TODO: Goto extent of infected buildings
        view.goTo(sceneLayer.fullExtent);
      }
      window.resetMap = resetMap;
    });
  </script>
</head>

<body onload="main();">
  <div id="viewDiv">
  </div>
  <div id="paneDiv">
    <div id="restoreDiv"><button id="restoreButton" class="runButton"><img id="restoreImg" src="images/restore-red.png"></button></div>
    <div id="paramsDiv" class="slidecontainer">
      <table class="inputTable">
        <tr>
          <td colspan=2>PARASOL Corp Simulation Settings
            <div id="minParamsDiv"><button id="minParamsButton" class="runButton"><img id="minParamsImg" src="images/minimize-red.png"></button>
            </div>
          </td>
        </tr>
        <tr>
          <td><input type="range" min="1" max="100" value="50" class="slider" id="infectionDuration"></td>
          <td class="sliderVal">Infection Duration: <span id="infectionDurationVal"></span> days</td>
        </tr>
        <tr>
          <td><input type="range" min="1" max="100" value="50" class="slider" id="deathRate"></td>
          <td class="sliderVal">Death rate: <span id="deathRateVal"></span>%</td>
        </tr>
        <tr>
          <td><input type="range" min="1" max="100" value="50" class="slider" id="infectionDistance"></td>
          <td class="sliderVal">Infection distance: <span id="infectionDistanceVal"></span> m</td>
        </tr>
        <tr>
          <td><input type="range" min="1" max="100" value="50" class="slider" id="infectionRate"></td>
          <td class="sliderVal">Infection rate: <span id="infectionRateVal"></span>%</td>
        </tr>
        <tr>
          <td class="sliderVal">
            <label>Total score at 100 days:</label></td>
          <td class="sliderVal"><input type="checkbox"
                name="modulation" id="modulation" checked></td>
        </tr>
        </table>
    </div>
  </div>
  <div id="runDiv">
      <button id="homeButton" class="runButton"><img src="images/home-red.png" alt="Home"/></button>
      <button id="resetButton" class="runButton"><img src="images/full-rewind-red.png" alt="Reset"/></button>
      <button id="stopButton" class="runButton"><img src="images/stop-red.png" alt="Stop"/></button>
      <button id="playButton" class="runButton"><img src="images/play-red.png" alt="Play"></button>
      <button id="playStepButton" class="runButton"><img src="images/play-step-red.png" alt="Play One Step"></button>
      <button id="pauseButton" class="runButton"><img src="images/pause-red.png" alt="Pause"></button>
      <button id="infoButton" class="runButton"><img src="images/info-red.png" alt="Info"></button>
  </div>
  <div id="scoreDiv">
      <table class="scoreTable">
        <tr>
          <td colspan=2 align="center">
            <div id="completeInfectionDiv">
            <div id="currentInfectionDiv"></div>
          </td>
        </tr>
        <tr>
            <td colspan=2>
                <span id="currentInfectedVal"></span>
            </td>
        </tr>
        <tr>
            <td colspan=2>
                Day <span id="currentDayVal"></span>
            </td>
        </tr>
      </table>
    </div>
  </div>

  <script src="scripts/groundhog-main.js"></script>
</body>
</html>
