<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Groundhog City Simulation</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.10/esri/css/main.css">
  <link rel="stylesheet" href="styles/groundhog_city.css">
  <script src="https://js.arcgis.com/4.10/"></script>

  <script>

    //State variables
    var isStopped = true;
    var isReset = true;
    var isPaused = false;
    var isRunning = false;
    var isRunningOneStep = false;

    const maxInfectionDuration = 6;
    const maxInfectionDistance = 300; // (m)

    //Globals
    var numSeeds = 0;
    var totalBuildings = -1;
    var infectionDay = 0;
    var svDefaultColor = [0,0,255,1];
    var infectionDistance = 100;
    var mortalityRate = 0; // 0..1
    var infectionDuration = 3;
    var infectionRate = 1; // 0..1


    // select infected houses
    // set ageing duration
    // set % terminal or reinfectable
    // set buffer distance
    // run simulation till pause or to 100 (keep score)
    //  Infect adjacent houses
    //  Age infection at each infected house
    //  Update renderer
    // TODO: Show score (Number of houses infected?)
    // DONE: Create on screen controls - reset, duration, terminal, distance
    // TODO: Show infection %, mortality %
    // TODO: Help dialog
    // TODO: Intro dialog/title dialog
    // DONE: Add ability to step forward one day >|

    // Credits
    // https://www.freeiconspng.com (skull icon)

    function objToString(obj){
      //console.log("in objToString()");
      var res = '';
      if (obj == null){
        res = 'null';
      } else {
        for (objItem in obj){
          res += objItem + ' ' + obj[objItem] + ' ' + typeof(objItem) + '\r\n';
        }
      }
      return res;
    }

    function createInfectedRenderers(iList, iColor){
    	var res = [];
      for (item in iList){
      	res[res.length] = JSON.parse('{"value": "' + iList[item] + '","label": "test","symbol": {"type": "mesh-3d","symbolLayers": [{"type": "fill","material": {"color": "' + iColor + '","colorMixMode": "replace"}}]}}');
      }
      return res;
    }

    function setSlider(sName, vName, min, max, current, execCode){
      var slider = document.getElementById(sName);
      var output = document.getElementById(vName);
      slider.min = min;
      slider.max = max;
      slider.value = current;
      output.innerHTML = slider.value;

      slider.oninput = function() {
        output.innerHTML = this.value;
        if (execCode){
          execCode();
        }
      }
    }

    require([
      "esri/Map",
      "esri/views/SceneView",
      "esri/layers/SceneLayer",
      "esri/layers/GraphicsLayer",
      "esri/Graphic",
      "esri/geometry/geometryEngine",
      "esri/renderers/smartMapping/statistics/summaryStatistics"
    ], function(Map,
      SceneView,
      SceneLayer,
      GraphicsLayer,
      Graphic,
      geometryEngine,
      summaryStatistics) {

      var infected = []; //will be an array of arrays
      var deceased = [];// will be an array of ids

      // Create Map
      var map = new Map({
        basemap: "dark-gray",
        ground: "world-elevation"
      });

      // Create the SceneView
      var view = new SceneView({
        container: "viewDiv",
        map: map,
        camera: {
          position: [-122.47876, 48.75368, 5000],
          tilt: 20,
          heading: 50
        },
        environment: {
          background: {
            type: "color",
            color: [30, 30, 30, 1]
          },
          starsEnabled: false,
          atmosphereEnabled: false
        }
      });

      // Create a GraphicsLayer to add buffer graphics
      var bufferLayer = new GraphicsLayer();
      map.add(bufferLayer);

      // Create SceneLayer and add to the map
      var sceneLayer = new SceneLayer({
        portalItem: {
          id: "fa0e0058ff394dd7a9902ede1d04721b"
        },
        popupEnabled: false
      });
      map.add(sceneLayer);

      sceneLayer.when(function(){
        //view.goTo(sceneLayer.fullExtent);

        var query = sceneLayer.createQuery();
        query.where = "YEAR = 2008";
        query.returnGeometry = true;
        //query.geometry = sceneLayer.fullExtent;
        //query.spatialRelationship = "contains";

        query.outFields = ['YEAR', 'TYPE'];
        sceneLayer.queryFeatures(query)
          .then(function(result){
            //console.log(result.features); // print the features to the console
            //console.log("Count " + result.features.length);
            //console.log("Geom " + result.features[0].length);
            var t = null;
            var tt = '';
            for (item in result.features){
              t = result.features[item].attributes;
              for (item2 in t){
                tt += item2 + " " + t[item2] + ",";
              }
              tt += '\r\n';
            }
            //console.log(tt);
            tt = '';
            var g = null;
            for (item in result.features){
              g = result.features[item].geometry;
              //g.symbol.color = [0, 0, 255, 0.3];
              //console.log("Symbol: " + objToString(g.symbol));
              t = g.extent;
              tt += g.type + '\r\n';
            }
            view.goTo(t);
            //console.log(tt);
          });
        //console.log('3');
        summaryStatistics({
          layer: sceneLayer,
          field: "YEAR"
        }).then(function(stats){
          console.log('Total buildings = ' + stats.count);
          totalBuildings = stats.count;
        });
      });

      // Create MeshSymbol3D for symbolizing SceneLayer
      var symbol = {
        type: "mesh-3d", // autocasts as new MeshSymbol3D()
        symbolLayers: [{
          type: "fill", // autocasts as new FillSymbol3DLayer()
          // If the value of material is not assigned, the default color will be red
          material: {
            color: [255, 0, 0]
          }
        }]
      };

      var infectedList = [1808,1752,1712];

      function getUniqueValueRenderer() {
        var res = {
          type: "unique-value",
          field: "OBJECTID",
          defaultSymbol: {
            type: "mesh-3d",
            symbolLayers: [{
              type: "fill",
              material: {
                color: svDefaultColor,
                colorMixMode: "replace"
              }
            }]
          },
          uniqueValueInfos: [],
          legendOptions: { title: "Infected" }
        };
        res.uniqueValueInfos = createInfectedRenderers(infected[0], "red");
        return res;
      }

      sceneLayer.renderer = getUniqueValueRenderer();

      //for testing
      var polySym = {
        type: "simple-fill", // autocasts as new SimpleFillSymbol()
        color: [140, 140, 222, 0.5],
        outline: {
          color: [0, 0, 0, 0.5],
          width: 2
        }
      };

      function getNeighbors(oid){
        //Query the scene layer by id to get the graphic

        var query = sceneLayer.createQuery();
        query.where = "OBJECTID = " + oid;
        query.returnGeometry = true;
        query.outFields = ['YEAR', 'TYPE'];
        var resultGeom = null;
        sceneLayer.queryFeatures(query)
          .then(function(result){
            resultGeom = result.features[0].geometry;
            //console.log("resultGeom = " + resultGeom.type);

            //Query the scene layer by a distance from the graphic geometry
            var query2 = sceneLayer.createQuery();
            query2.geometry = geometryEngine.geodesicBuffer(resultGeom,
              parseInt(infectionDistance)/1000, "kilometers");
            console.log("Using infectionDistance variable");
            bufferLayer.add(new Graphic({
              geometry: query2.geometry,
              symbol: polySym
            }));
            query2.spatialRelationship = "intersects";
            query2.outFields = ['OBJECTID', 'YEAR', 'TYPE'];
            sceneLayer.queryFeatures(query2)
              .then(function(result2){
                for (item in result2.features){
                  t = result2.features[item].attributes.OBJECTID;
                  //console.log(t);

                  //TODO: Add results to the newly infected list

                }
              });
          });

        //return an array of the neighbor OBJECTIDs minus the id of the input graphic
      }

      // capture click events on the view
      view.on("click", function(event) {
        // get the returned screen x, y coordinates and use it
        // with hitTest to find if any graphics were clicked
        // (using promise chaining for cleaner code and error handling)
        view.hitTest(event).then(function(response) {
          var result = response.results[0];
          if (result && result.graphic) {
            return result.graphic;
          }
        }).then(function(graphic) {
          if (graphic){// for some reason this is coming across as undefined
            // now extract the object id from the graphic
            if (isStopped && isReset){
              var tid = graphic.attributes.OBJECTID;
              var tind = infected[0].findIndex(function(tval){return (tval == tid);});
              //console.log("tid=" + tid + "  tind=" + tind);
              if (tind > -1){
                infected[0].splice(tind, 1);
              } else {
                infected[0][infected[0].length] = tid;
              }
              //console.log(JSON.stringify(graphic));
              //console.log(infectedList);
              sceneLayer.renderer = getUniqueValueRenderer();
              //getNeighbors(tid); This was a test method.  Don't need to do this any longer.
            }
          } else {
            console.log("got undefined graphic");
          }
        }).catch(function(error) {
          console.error(error);
        });
      });

      view.ui.add("paneDiv", "bottom-left");
      view.ui.add("runDiv", "bottom-right");
      view.ui.add("scoreDiv", "top-right");

      function resetInfected(){
        //Set up the infected array
        infected = [];
        for (iD = 0; iD < infectionDuration; iD++){
         infected.push([]);
        }
        console.log('Initialized infected[]: ' + infected);
      }
      window.resetInfected = resetInfected;

      function initializeSim(infectionDuration){
       //tODO: Clear any graphics layers

      //init infected array
      resetInfected();

       //Clear numSeeds
       numSeeds = 0;
       //Clear infection day
       infectionDay = 0;

       isStopped = true;
       isReset = true;
       isPaused = false;
       isRunning = false;

       bufferLayer.removeAll();
       setProgress("currentInfectionDiv", 0, false, "currentInfectedVal", (0 + "%"));
       document.getElementById("currentDayVal").innerHTML = "0";
      }
      window.initializeSim = initializeSim;

      //Change the position of a vertical progress indicator
      function setProgress(divName, val, down, textSpan, textVal) {
      	if (!down){
        	val = 100 - val;
        }
        var elem = document.getElementById(divName);
        elem.style.height = val + '%';
        if (textVal){
          document.getElementById(textSpan).innerHTML = textVal;
        }
      }
      window.setProgress = setProgress;

      //Run the Simulation
      function runSim(){
        if (isRunning || isRunningOneStep){

          if (infectionDay == 0){
            var simParams = "\r\nSim Params\r\n";
            simParams += "mortalityRate: " + mortalityRate + "\r\n";
            simParams += "infectionDistance: " + infectionDistance + "\r\n";
            simParams += "infectionDuration: " + infectionDuration + "\r\n";
            simParams += "infectionRate: " + infectionRate + "\r\n";
            simParams += "initial infection count: " + infected[0].length + "\r\n";
            console.log(simParams);
          }

          // TODO: Create simulation logic
          // Loop through the current infected list

          // Create a geometry to use to union the buffers
          var query = null;
          var resultGeom = null;
          var bigBuffer = null;
          var tempBuffer = null;
          var newlyInfected = [];

          for (age in infected){
            for (iid in infected[age]){
              query = sceneLayer.createQuery();
              query.where = "OBJECTID = " + infected[age][iid];
              query.returnGeometry = true;
              query.outFields = ['YEAR', 'TYPE'];
              // Query the feature to get the grapic
              sceneLayer.queryFeatures(query)
                .then(function(result){
                  resultGeom = result.features[0].geometry;
                  //console.log("resultGeom = " + resultGeom.type);

                  // Create the buffer based on the graphic and infectionDistance
                  tempBuffer = geometryEngine.geodesicBuffer(resultGeom,
                    parseInt(infectionDistance)/1000, "kilometers");

                  // Union the buffer to the combined buffer geometry
                  if (bigBuffer == null){
                    bigBuffer = tempBuffer;
                  } else {
                    bigBuffer = geometryEngine.union([tempBuffer, bigBuffer]);
                  }
                });
            }
          }

          if (bigBuffer != null){
            // Draw the unioned buffer
            bufferLayer.add(new Graphic({
              geometry: bigBuffer,
              symbol: polySym
            }));

            // Intersect the unioned geometry with the layer to get the feature set
            var query2 = sceneLayer.createQuery();
            query2.geometry = bigBuffer;
            query2.spatialRelationship = "intersects";
            query2.outFields = ['OBJECTID', 'YEAR', 'TYPE'];
            sceneLayer.queryFeatures(query2)
              .then(function(result2){
                for (item in result2.features){
                  t = result2.features[item].attributes.OBJECTID;
                  // Add results to the newly infected list
                  // TODO: change this to factor in infectionRate
                  newlyInfected.push(t); // do I need to parseInt here?
                }
              });

            if (newlyInfected.length > 1){
              // Sort newlyInfected
              newlyInfected.sort(function(a, b){return a-b}); // assuming IDs are numbers

              // Deduplicate newlyInfected
              var tt = 1;
              while (tt < newlyInfected.length){
                if(newlyInfected[tt] == newlyInfected[tt-1]){
                  newlyInfected.splice(tt, 1);
                } else {
                  tt++;
                }
              }
            }
          } // end if bigBuffer != null
          console.log("bigBuffer is null: " + (bigBuffer == null));

          // Calculate if the current oldest infected should be cleared or killed; if killed, add them to the deceased list
          for (old in infected[infected.length-1]){
            if (Math.random() < mortalityRate){
              deceased.push(infected[infected.length-1][old]);
            }
          }
          deceased.sort();
          console.log("Deceased count: " + deceased.length);

          // Age the arrays of the infected list
          for (ai = 0; ai < infected.length - 1; ai++){
            infected[ai + 1] = infected[ai];
          }

          // Add the new items from the temp array to the 0 position of infected list
          infected[0] = newlyInfected;

          // TODO: redraw the renderers
          sceneLayer.renderer = getUniqueValueRenderer();

          //update the progress indicator
          var count = 0;
          for (age in infected){
            count += infected[age].length;
          }
          count += deceased.length;
          var pctCount = Math.round(count/totalBuildings*100, 2);
          setProgress("currentInfectionDiv", pctCount, false, "currentInfectedVal", (pctCount + "%"));
          console.log("Total infected + deceased: " + count);

          infectionDay++;
          document.getElementById("currentDayVal").innerHTML = infectionDay;
        } else if (isPaused) {
        }
        if (!isRunningOneStep){
          setTimeout("runSim();", 500);
        }
      } // end runSim
      window.runSim = runSim;

      //reset the map extent to a helpful extent
      function resetMap(){
        //TODO: Goto extent of infected buildings
        view.goTo(sceneLayer.fullExtent);
      }
      window.resetMap = resetMap;
    });
  </script>
</head>

<body onload="main();">
  <div id="viewDiv">
  </div>
  <div id="paneDiv">
    <div id="restoreDiv"><button id="restoreButton" class="runButton"><img id="restoreImg" src="images/restore-red.png"></button></div>
    <div id="paramsDiv" class="slidecontainer">
      <table class="inputTable">
        <tr>
          <td colspan=2>PARASOL Corp Simulation Settings
            <div id="minParamsDiv"><button id="minParamsButton" class="runButton"><img id="minParamsImg" src="images/minimize-red.png"></button>
            </div>
          </td>
        </tr>
        <tr>
          <td><input type="range" min="1" max="100" value="50" class="slider" id="infectionDuration"></td>
          <td class="sliderVal">Infection Duration: <span id="infectionDurationVal"></span> days</td>
        </tr>
        <tr>
          <td><input type="range" min="1" max="100" value="50" class="slider" id="deathRate"></td>
          <td class="sliderVal">Death rate: <span id="deathRateVal"></span>%</td>
        </tr>
        <tr>
          <td><input type="range" min="1" max="100" value="50" class="slider" id="infectionDistance"></td>
          <td class="sliderVal">Infection distance: <span id="infectionDistanceVal"></span> m</td>
        </tr>
        <tr>
          <td><input type="range" min="1" max="100" value="50" class="slider" id="infectionRate"></td>
          <td class="sliderVal">Infection rate: <span id="infectionRateVal"></span>%</td>
        </tr>
        <tr>
          <td class="sliderVal">
            <label>Total score at 100 days:</label></td>
          <td class="sliderVal"><input type="checkbox"
                name="modulation" id="modulation" checked></td>
        </tr>
        </table>
    </div>
  </div>
  <div id="runDiv">
      <button id="homeButton" class="runButton"><img src="images/home-red.png" alt="Home"/></button>
      <button id="resetButton" class="runButton"><img src="images/full-rewind-red.png" alt="Reset"/></button>
      <button id="stopButton" class="runButton"><img src="images/stop-red.png" alt="Stop"/></button>
      <button id="playButton" class="runButton"><img src="images/play-red.png" alt="Play"></button>
      <button id="playStepButton" class="runButton"><img src="images/play-step-red.png" alt="Play One Step"></button>
      <button id="pauseButton" class="runButton"><img src="images/pause-red.png" alt="Pause"></button>
      <button id="infoButton" class="runButton"><img src="images/info-red.png" alt="Info"></button>
  </div>
  <div id="scoreDiv">
      <table class="scoreTable">
        <tr>
          <td colspan=2 align="center">
            <div id="completeInfectionDiv">
            <div id="currentInfectionDiv"></div>
          </td>
        </tr>
        <tr>
            <td colspan=2>
                <span id="currentInfectedVal"></span>
            </td>
        </tr>
        <tr>
            <td colspan=2>
                Day <span id="currentDayVal"></span>
            </td>
        </tr>
      </table>
    </div>
  </div>

  <script src="scripts/groundhog-main.js"></script>
</body>
</html>
